## 串联小腿

### 物理结构
普通4连杆机构，由于膝关节存在一个限位，导致髋关节两个杆无法转到倒'V'型，使得该腿的环境适应性有限。

走线较为简单，四个髋关节CAN1接到前方下面分线板，两个轮电机CAN2经滑环到后面上分线板，后面下放置C板。

| 关键     | 内容                                                         |
| -------- | ------------------------------------------------------------ |
| 零点     | 电机对应的杆平行位置                                         |
| 正方向   | 左 前 1 逆时针+ ID1<br/>左 后 3 逆时针+ ID3<br/>右 前 2 顺时针+ ID2<br/>右 后 4 顺时针+ ID4 |
| 电机类型 | 髋关节 DM4310 2EC<br/>轮电机 DJI3508 + 减速箱                |
| 分配     | CAN1 髋关节电机<br/>CAN2 轮电机                              |

### CAN分配

| CAN  | 电机ID | 反馈ID(master) | 类型 | 正方向 |
| ---- | ------ | -------------- | ---- | ------ |
| CAN1 | 0x01   | 0x11           | 左前 | 逆时针 |
| CAN1 | 0x02   | 0x12           | 右前 | 逆时针 |
| CAN1 | 0x03   | 0x13           | 左后 | 逆时针 |
| CAN1 | 0x04   | 0x14           | 右后 | 逆时针 |
| CAN2 |        |                |      |        |
| CAN2 |        |                |      |        |

### 问题

- 达妙电机控制与反馈

  选择MIT模式作为控制模式 笔者发现达妙电机是有点东西的 (不好评价). 

  - 使能问题  

    在freertos任务中使能需加大约1ms的延时，~~定时器使能不需要~~ 不要定时器内只使能一次（或者说使能存在必须一定延时）

  - 发送问题

    达妙电机 (所有都有这个情况, 只要你总线上挂着达妙电机) 发送以三个为一组, 如果负载率过高, 会只保留第一组的所有值. 解决方案: 把你的总线电机分配至每个组都小于3, 每个包分别切换发送, 两次之间保证一定延时即可(开源测试保证200us即可, 我选择的是500us切换两组左右髋关节电机分别发送, 经测试满足1k控制频率, 收发没有明显问题). 
    
  - CAN负载
  
    笔者选择CAN 1M波特率, 因为达妙是一发一收, 所以发送频率决定接收频率. 在测试中, 发现200hz频率负载在8%左右, 1khz频率负载率在94%左右, 有极少数丢包情况. ~~目前选择的是1k频率. (由于达妙是一发一收, 最终上位机检测实际频率大于1k, 在1.2k左右)~~ 算了，CAN负载太高， 选取600us切换，单电机发送833hz，负载80%，1ms切换，单电机500hz，负载40%。选取1ms切换方案。
    
  - 控制选择:
  
    使用TIM7定时器发送CAN数据, 设置周期为500us, 实际运行周期 (包含CAN发送) 在0.4996-0.5000ms左右, 其中0.5000ms占比大于60%, 符合控制精度要求. 由于定时器默认是上电即启动, 会导致定时器发送可能吞掉初始化的命令. 采用初始化完成后启动定时器TIM7发送或者在定时器启动初始化都可以，笔者选择方法1，舍弃定时器启动。
  
    > 笔者还遇到一个超级抽象问题，电机2必须使能10次以上才行，其他都能一次即可，但是单独使能都可以一次使能。结果是分线板的对应端口有点虚连。所以一个良好的硬件很重要。


- 陀螺仪安装
R标朝位移正方向和仿真中陀螺仪反装极性一致，注意符号。

- 建模方向
TODO 粘图

左腿 phi 逆时针为负
右腿 phi 逆时针为负
低头 phi 左右 -+


- 极性
因为减速箱反装原因，导致仿真和实物还是有很多差异，起码我调试的过程是这样的。简要总结一下调试要点，有时间我在彻底统一和仿真的极性。（必须）TODO

注意机体应该能自稳，即车身朝一个方向偏，轮子会朝对应方向走来平衡。对于腿来说，~~调试极性应使车身朝下偏，左腿向后，右腿向前；车身朝上偏，左腿向前，右腿向后。~~ 应该是同左腿的方向偏，补偿重心变化。极性调试的没有问题，腿本身上电应不会转动，抖动，伸缩，轮应响应较为灵敏。注意不要给太大的力，调试的时候为了防止肘击，可以把对应项R权重给大，以削弱作用看极性。注意极性应轮电机改，髋关节一起改。

1. 板凳：因为绑腿的时候串腿比较难以完全相对于机体静止，故需要简要设置一下平衡零点。另对于腿来说板凳只是简要验证一下极性就好，所以只要能勉强稳定就可以。
```c
DJI_Torque_Control(&hcan2, 0x200, Leg_r.LQR.torque_setW, 0.0f, Leg_l.LQR.torque_setW, 0.0f);
```

2. 单腿去轮：确定 F T_p 计算没有问题，确定建模方向一致后，选择一组参数，保证不会连续转动，车身往两个方向倾，观察左右腿髋关节输出会不会使腿偏移。

注意，静止状态上电后应腿会保持竖直状态，不会转动，代表电机输出极性正确。此时观察腿转动方向，机体倾斜后，腿应找使得机体重心稳定的点的方向转动。若完成后，即调试完了总输出极性（或者这样理解，力矩极性，我这里认为力矩全为正值，改变总输出极性）。
```c
object->LQR.torque_setT[0] = object->vmc_calc.JRM[0][0] * object->LQR.F_0 + \
                             object->vmc_calc.JRM[0][1] * object->LQR.T_p;
object->LQR.torque_setT[1] = object->vmc_calc.JRM[1][0] * object->LQR.F_0 + \
                             object->vmc_calc.JRM[1][1] * object->LQR.T_p;

mit_ctrl(&hcan1, 0x01, 0,0,0,0, -Leg_l.LQR.torque_setT[0]);
mit_ctrl(&hcan1, 0x03, 0,0,0,0, -Leg_l.LQR.torque_setT[1]);
```

3. 单腿：加轮子后，调节R矩阵保证轮子不会太大，轻托另一侧腿，模拟平衡，让该腿自己去找平衡点，理论可以平衡。

4. 双腿去轮：~~注意建模方向，另一条腿正方向是反的（TODO 我能不能直接建模成一致的，这样防劈叉可能更好了），可能有点难以单腿平衡，建议腿的方向摆动与另一个是相反的，代表Ok~~

以上说法错误，右腿应镜像反对称建模，即偏移机体，转向相同。通过修正 $ \phi $ 的符号，确定两腿同方向摆动。
```c
object->stateSpace.phi = -imu->pitch / 57.3f;
```

5. 防劈叉：保证双腿向同方向摆动，补偿差距。建议先调这一个，一般双腿不加防劈叉会没有负载的情况下会有0.02以内的误差，调的时候可以随便指定一个极性，然后在kp选取正负测试极性是否正确，最后加上负载（即下地测试）看补偿效果。
```c
object->LQR.T_p = object->LQR.T_p + object->LQR.dF_delta;
const float Delta_control[3] = {100.0f, 0.01f, 0.0f};
PID_init(&object->pid.Delta, PID_POSITION, Delta_control, 10.0f, 0.0f);
```
最后发现限幅10还是有点小，最后误差在0.003左右。累了，随便调吧。

6. roll补偿：保证站立的时候车身不会倾斜过大

7. yaw补偿：保证不会疯转
```c
const float Yaw_control[3] = {1.0f, 0.001f, 250.0f};
PID_init(&object->pid.Yaw, PID_POSITION, Yaw_control, 0.4f, 0.0f);
```
注意两个电机最大输出扭矩，给个20%左右，观察pid输出的大小，可先全给正，然后在debug里选择Kp的正负值，观察err是否收敛，确定极性。

另外，该项kd需置大，否则会转动的时候一顿一顿然后走直线会左右摇晃。


> 以上都调好后，车理论上是可以勉强行走了，但是距离上场水平还差得远。因此需要继续打磨。

- 建模参数

建模精度直接决定你的控制精度，务必你的每一项物理量精度要求都要非常高，这将极大简化你的调参时间。

起初我使用的是转动惯量仿真的参数，发现如何给位移的权重总是不收敛
```python
I_p_val = m_p_val * leg_length**2 / 12.0 + m_p_val * 0.0119**2
I_M_val = M_val * Body_val**2 / 12.0 + Body_val * l_val**2 
```
我选用平行轴定理，重新定位转轴距离，后求得的两个虚拟杆的转动惯量，在相同lqr参数下，变腿长将车体不会抖动。

对比：
```c
float ChassisL_LQR_K[12] = { -2.03170922, -0.17506895, -0.67137030, -0.57916018, 3.85115572, 0.32133360, 11.53893677, 1.39790403, 7.41122070, 5.97104687, 27.60178681, 0.41381166 };

float ChassisL_LQR_K[12] = { -2.33647421, -0.21081156, -0.87849161, -0.74250485, 2.75285200, 0.19102688, 7.69537749, 0.93227315, 4.77757781, 3.87075519, 37.88178286, 0.87056623 };
```
> 这比调参影响的效果差太多了。

重要程度：转动惯量 > 车身质量 > 腿长 > 杆质量


- 支持力解算

和pid腿长有关，先调好腿长后再进行支持力解算。


- lqr 测试


- 倒地自启

~~没想到只要建模足够精确，lqr还没怎么调就能自己起来了，只是有点快，现在看来只需要异常模式下给一个限幅就能实现了。可能需要加大 $\theta$ 的权重就可以。~~

不行，上个方案无法控制速度。经过我肘击经验，暂时确定了以下方案。

1. 倒地状态判断：倒地后被判断为自启状态，后双腿位置位于身后时进入板凳模式收腿起立，最后一定时间后稳定后站立加腿。
2. 旋转方案： $\theta$ 的大小为 $\left[ \frac{-\pi}{2} , \frac{\pi}{2} \right]$ ，前为正后为负，选用规划 $\theta$ 目标方案。目前有两个测试：
  - $\theta$ 位控， $\dot{\theta}$ 作为导数，目前是实现了停在固定点，要求K矩阵对应权重拉大。
  - $\dot{\theta}$ 速控， $\theta$ 作为积分，没有实现。
  - ~~直接限幅输出：无法确定方向和大小。~~
  - ~~给一个固定力矩：旋转过快。~~
3. 自启方案：先收腿至最短，后板凳模型lqr参数起立。
4. 站立方案：稳定一定时间后起立。

倒地自启分为三个阶段，1 腿部旋转 2 板凳起立 3 普通K矩阵稳定

第一阶段经过测试后，抛弃了原限幅方案，位置控制方案，LQR修正方案，选择pid速控方案（其他方案真不行，但是pid会形成类似pwm波形，会很震荡）。后面会尝试给T_p能否实现旋转，这样就能控制腿长了。板凳起立选择重新给QR矩阵，注意R矩阵和限幅的选取，将决定回正效果是否会把腿甩到对面。

```python
# 8. LQR 求解
Q = np.diag([6000, 1, 300, 1, 6000, 1])
R_mat = np.diag([30, 1]) 
```

```c
if (left->status.stand_count >= 500 || right->status.stand_count >= 500)  // 回正时间

left->limit.T_max = 1.0f;     // 板凳限幅
right->limit.T_max = 1.0f;
left->limit.W_max = 0.4f;
right->limit.W_max = 0.4f;
```

1. 采用pid方案测试。
pid给小才行，大了会震荡导致上不去。该方案不能保证旋转的时候保持伸长状态，且单环Pid劣势太大。

该方案作为初版测试成功，效果不错，任意状态都能自启，失误率大约20%左右进入二次起立，但是连续起立成功率明显下降，可能和QR矩阵选取有关。调参后应该能得到一版较为稳定的参数。

2. T_p指定项旋转，使用Pid控制速度，这样能控制腿长伸长。
理论可以控腿长，双环Pid，内环速度外环力矩。


- 滤波测试

状态空间滤波，本意是想滤除导数项的误差，没想到 $\alpha = 0.9$ 的效果很差， $\alpha$ 不宜减小，看来普通的一阶低通是不可以的。待我有时间测试一下巴特沃斯，选取500hz通带，滤除一次干扰。

- 磕台阶

1. 失能使能方案
2. 收腿起立方案
3. model based 方案

- 无线串口调lqr

目前采用脚本计算K矩阵后发送到对应指定串口上，实时修改LQR矩阵，便于调参。由于调试器原因，debug模式下使用该方案会导致串口发送卡顿。
```python
send_k('COM36')
```

- 零点漂移

~~目前猜测是杆质心不对，但是尝试赋予 $\theta$ 目标值并没有很大效果。~~

应该是零点标定精度问题，杆质心起到的效果要小于零点标定。

- 拟合K阵

仿真没有试过，感觉实际有点难调。

update: 和单K阵完全不一样的思路，参数需要大胆给，尤其是位移项。另外，pid参数，尤其yaw补偿需要kd至小。拟合后， $\theta$ 的效果明显加强，变腿长不再抖动，且调参的时候 $x$ 权重较单lqr需要给大。

实际在高腿长的情况下明显变好。


- 减速箱

当时忘了乘减速比，现在乘了之后参数很难调，有时间再测试吧，不确定是否输出大扭矩了。~~另外猜测零点漂移问题就是这个扭矩问题，输出太小，包括 $\theta$ 收敛慢。~~

update: 应该是电机屁股扭矩输出，一开始误打误撞整的居然挺接近真实扭矩的，0.7倍。后面乘上以后，R参数比较接近了，但是不能至1，输出太大，一般给到30-60左右即可。这个参数懒了，先用原版吧。

猜测错误，零点漂移应该是时标定的时候存在误差。

- 速度规划

传统斜坡函数过于简单，加速度不可控，因此选择高次多项式插值实现。[教程](https://seashore.top/Blog_ButterFly/2025/02/21/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BD%A8%E8%BF%B9%E8%A7%84%E5%88%92/)

目前我采用的是二次多项式拟合速度，加速度为斜坡，待优化成可指定加速度变化。

$$
v = 
\begin{cases}
    -\frac{1}{2}kt^2+a_{max}t & 0 \leq v \leq v_{max} \\
    -\frac{1}{2}kt^2+v_{max}      & 0 \leq v \leq v_{max} 
\end{cases}
$$

- 跳跃

选择原仿真方案，即腿长变化成阶跃变化，因为我考虑其他拟合曲线插值方法还是有点不太具有良好适应性。原三次多项式插值需要纵轴速度，可行性有限。

- 优先级问题

注意任务优先级问题。提高`move task`优先级后，原`init`函数前应给一定延时以保证CAN通信正常启动。（或者你把所有初始化放在一起也可以）。

提高优先级后，不少状态变量变化需要重新调参。（需要R给大？）

```python
# 对比
R_mat = np.diag([200, 1])    # Normal
R_mat = np.diag([500, 300])  # High
```

### TODO

- 定时器中使能static init改为电机状态参数
- 防止丢帧，使能多加几次
- 不同电机发送频率和解算频率的影响
- 变lqr中质心拟合（质心转动惯量对参数影响很大），通过视觉发送实时改变
- 滤波器设计

### 任务
- 2026-1-6 杆拟合质心 $\theta$ 求解，卡尔曼滤波打滑测试，~~无线调参，拟合K矩阵~~
- 2026-1-8 倒地判断精准，~~缓慢旋转，roll补偿精准~~，飞坡测试成功，本末电机控制，~~导数积分滤波增加尝试消除震荡~~
- 2026-1-9 腿后倒地自启，速度规划，跳跃

### 日志

- 2025-12-29 完成简单走线和电机设置控制，可以写解算代码了
- 2025-12-30 四点总算完成vmc正解算了，今年能让腿站起来吗
- 2026-1-2   串腿能站了！！可惜没有年前实现，话说极性也太难调了，比我写代码时间都长，不愧测试岗挣得多
- 2026-1-3   成功确定极性调法，比较稳定的一版，可惜没调lqr
- 2026-1-4   确定倒地自启方案，一定要调作息
- 2026-1-8   发现减速箱没有考虑外部减速比，唉，先做其他的吧
- 2026-1-10  倒地自启初版成功，虽然很晃，但终究是走了一大步。